<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="生活不止苟且，还有诗和远方">
<meta property="og:type" content="website">
<meta property="og:title" content="LittleCorn个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LittleCorn个人博客">
<meta property="og:description" content="生活不止苟且，还有诗和远方">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LittleCorn个人博客">
<meta name="twitter:description" content="生活不止苟且，还有诗和远方">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LittleCorn个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LittleCorn个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">碎碎念~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/NodeJS学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/NodeJS学习笔记/" itemprop="url">NodeJS学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T12:28:10+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJS/" itemprop="url" rel="index">
                    <span itemprop="name">NodeJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Node本身运行V8 JavaScript。V8 JavaScript引擎是Google用于其Chrome浏览器的底层JavaScript引擎。Google使用V8创建了一个用C++编写的超快解释器，该解释器拥有另一个独特特征：您可以下载该引擎并将其嵌入任何应用程序。V8 JavaScript引擎并不仅限于在一个浏览器中运行。因此，Node.js实际上会使用Google编写的V8 JavaScript引擎，并将其重建为可在服务器上使用。</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>他是一个JavaScript运行环境</li>
<li>依赖于Chrome V8引擎进行代码解释</li>
<li>事件驱动</li>
<li>非阻塞I/O</li>
<li>轻量、可伸缩，适用于实时数据交互应用</li>
<li>单进程、单线程</li>
</ul>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。</p>
<p><strong>NodeJS是怎么解决并发连接这个问题的：</strong></p>
<p>更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。</p>
<h3 id="I-O阻塞"><a href="#I-O阻塞" class="headerlink" title="I/O阻塞"></a>I/O阻塞</h3><p>NodeJS非阻塞I/O，发射/监听事件来控制执行过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> EventProxy();</span><br><span class="line"></span><br><span class="line">proxy.all(<span class="string">"profile"</span>,<span class="string">"timeline"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">profile,timeline</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.getUser(<span class="string">"username"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">profile</span>)</span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">"profile"</span>,profile);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.getTimeline(<span class="string">"username"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">timeline</span>)</span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">"timeline"</span>,timeline);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行的，因此，拿profile的动作触发一个I/O事件，马上就会执行拿timeline的动作，两个动作并行执行，假如各需要1S，那么总的时间也就是1S。它们的I/O操作执行完成后，发射一个事件，profile和timeline，事件代理接收后继续往下执行后面的逻辑，这就是NodeJS非阻塞I/O的特点。</p>
<p>总结一下：Java、PHP也有办法实现并行请求（子线程），但NodeJS通过<strong>回调函数（Callback）和异步机制</strong>会做得很自然。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong>（事件驱动、I/O非阻塞）</p>
<ul>
<li>高并发</li>
<li>适合I/O密集型应用</li>
</ul>
<p><strong>缺点：</strong>（单进程、单线程）</p>
<ul>
<li>不适合CPU密集型应用，CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使的后续I/O无法发起。（<strong>解决方案</strong>：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起）</li>
<li>只支持单核CPU，不能充分利用CPU。</li>
<li>可靠性低，一旦代码某个环节崩溃，整个系统都会崩溃。（解决方案如下）</li>
<li>开源组件库质量层次不齐，更新快，向下不兼容。</li>
<li>Debug不方便，错误没有stack trace。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>开启多个进程，每个进程绑定不同的端口，用反向代理服务器如 Nginx 做负载均衡，好处是我们可以借助强大的 Nginx 做一些过滤检查之类的操作，同时能够实现比较好的均衡策略，但坏处也是显而易见——我们引入了一个间接层。</li>
<li>多进程绑定在同一个端口侦听。在Node.js中，提供了进程间发送“文件句柄” 的功能，这个功能实在是太有用了。</li>
<li>一个进程负责监听、接收连接，然后把接收到的连接平均发送到子进程中去处理。</li>
<li>在Node.js v0.5.10+ 中，内置了cluster 库，官方宣称直接支持多进程运行方式。Node.js 官方为了让API 接口傻瓜化，用了一些比较tricky的方法，代码也比较绕。这种多进程的方式，不可避免的要牵涉到进程通信、进程管理之类的东西。</li>
</ul>
<h3 id="适合NodeJS的场景"><a href="#适合NodeJS的场景" class="headerlink" title="适合NodeJS的场景"></a>适合NodeJS的场景</h3><ol>
<li>RESTful API</li>
</ol>
<p>这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。</p>
<ol>
<li>统一Web应用的UI层</li>
</ol>
<p>目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。</p>
<p>不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。</p>
<ol>
<li>大量Ajax请求的应用</li>
</ol>
<p>例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。　　</p>
<p><strong>总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Fetch学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Fetch学习笔记/" itemprop="url">Fetch学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T16:16:36+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>多年来，XMLHttpRequest一直是web开发者的亲密助手。无论是直接的，还是间接的， 当我们谈及Ajax技术的时候，通常意思就是基于XMLHttpRequest的Ajax，它是一种能够有效改进页面通信的技术。 Ajax的兴起是由于Google的Gmail所带动的，随后被广泛的应用到众多的Web产品（应用）中，可以认为， 开发者已经默认将XMLHttpRequest作为了当前Web应用与远程资源进行通信的基础。 而本文将要介绍的内容则是XMLHttpRequest的最新替代技术——Fetch API， 它是W3C的正式标准，本文将会介绍Fetch API的相关知识，以及探讨它所能使用的场景和能解决的问题。</p>
<p>XMLHttpRequest在设计上不符合全责分离的原则，将输入、输出和用事件来跟踪的状态都混杂在一个对象里。而且基于事件的异步模型写起来也没有现代的promise、generator、asyc友好。</p>
</blockquote>
<h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>Fetch API提供了一个fetch()方法，它被定义在BOM的window对象中，你可以用它来发起对远程资源的请求。 该方法返回的是一个Promise对象，让你能够对请求的返回结果进行检索。</p>
<p><strong>优点：</strong></p>
<ul>
<li>语法简单，更加语义化。</li>
<li>基于标准Promise实现，支持asyc/await。</li>
<li>同构方便，使用isomorphic-fetch</li>
</ul>
<p>原生fetch支持率：</p>
<p><img src="/images/fetch浏览器兼容性.jpg" alt="image"></p>
<blockquote>
<p>Fetch API在各大浏览器支持率不高，可以通过polyfill来实现不同浏览器的兼容性问题。</p>
</blockquote>
<p>原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+ ：</p>
<ul>
<li>由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim, es5-sham</li>
<li>引入 Promise 的 polyfill: es6-promise</li>
<li>引入 fetch 探测库：fetch-detector</li>
<li>引入 fetch 的 polyfill: fetch-ie8</li>
<li>可选：如果你还使用了 jsonp，引入 fetch-jsonp</li>
<li>可选：开启 Babel 的 runtime 模式，现在就使用 async/await</li>
</ul>
<p>Fetch polyfill 的基本原理是探测是否存在 window.fetch 方法，如果没有则用 XHR 实现。这也是 github/fetch 的做法，但是有些浏览器（Chrome 45）原生支持 Fetch，但响应中有中文时会乱码，老外又不太关心这种问题，所以我自己才封装了 fetch-detector 和 fetch-ie8 只在浏览器稳定支持 Fetch 情况下才使用原生 Fetch。</p>
<h3 id="fetch使用"><a href="#fetch使用" class="headerlink" title="fetch使用"></a>fetch使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, option).then( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>fetch 的url 参数是必须的，option参数可选。</p>
<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>来看看fetch的可选参数option的可选值，fetch默认是get方法，也可以在option中设置为其他方法。</p>
<ul>
<li>method：get | post 等方法</li>
<li>headers：任何你想加到请求中的头，可以是对象字面量的方式也可以是通过 Headers</li>
<li>body：发送给服务器的信息， 可以是JSON, ufferSource, FormData, URLSearchParams, 或 USVString。注意get和HEAD请求没有body</li>
<li>mode：请求模式， 可选值为 cors, no-cors, same-origin, 或 navigate，cors-with-forced-preflight。默认值应该为 cors。但在Chrome中，Chrome 47 之前的版本默认值为 no-cors ，自Chrome 47起，默认值为same-origin。–MDN Request</li>
<li>credentials：在请求中是否需要凭据。在请求数据中根据是否需要携带Cookie 来设置其值，可选值为omit（在请求中不懈怠认证凭据（Cookie））, same-origin（在同原站点下包含凭据）, 或 include（对所有网站包含认证凭据）</li>
<li>cache：如何处理缓存，可取值有 default | no-store | no-cache | reload | force-cache | only-if-cached</li>
<li>redirect：对重定向的处理，可取值 follow, error, redirect</li>
<li>referrer：一个指定了no-referrer, client, 或一个 URL的 USVString 。默认值是client</li>
<li>integrity: 包括请求的 subresource integrity 值 (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).</li>
</ul>
<p><strong>mode</strong></p>
<p>mode 参数便于 CORS， 设置不同的值可以使在不同的请求方式下，使得请求有效。</p>
<ul>
<li>cors：在同域和带有CORS响应头的跨域下可以请求成功</li>
<li>no-cors：常用于在跨域不带CORS场景下， 此时请求发出并且会有响应，但是此时type为“opaque”， status为0 ，js获取不到返回数据。</li>
<li>same-origin：在同域下请求</li>
<li>cors-with-forced-preflight：在请求前进行preflight 检查</li>
</ul>
<p><strong>headers</strong></p>
<p>该参数的值可以为对象字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers： &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以创建 Headers 对象，通过append() 和delete() 等方法对其进行操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append( <span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">    method: post,</span><br><span class="line">    headers: headers,</span><br><span class="line">    body: &#123;</span><br><span class="line">        name: <span class="string">"jack"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>自定义请求头信息极大地增强了请求的灵活性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 Headers 对象,注意是Headers，不是Header</span></span><br><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加(append)请求头信息</span></span><br><span class="line">headers.append(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">headers.append(<span class="string">'X-My-Custom-Header'</span>, <span class="string">'CustomValue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断(has), 获取(get), 以及修改(set)请求头的值</span></span><br><span class="line">headers.has(<span class="string">'Content-Type'</span>); <span class="comment">// true</span></span><br><span class="line">headers.get(<span class="string">'Content-Type'</span>); <span class="comment">// "text/plain"</span></span><br><span class="line">headers.set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某条请求头信息(a header)</span></span><br><span class="line">headers.delete(<span class="string">'X-My-Custom-Header'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象时设置初始化信息</span></span><br><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">    <span class="string">'X-My-Custom-Header'</span>: <span class="string">'CustomValue'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Fetch API不仅仅为你提供了一个fetch()方法。对于传统的XMLHttpRequest而言，你必须使用它的一个实例来执行请求和检索返回的响应。 但是通过Fetch API，我们还能够明确的配置请求对象。</p>
</blockquote>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义。所以在一个Fetch请求中，完全可以只使用Request 和 Response两个对象，通过Request 设置参数，通过Response 对返回值进行处理。</p>
<blockquote>
<p>request配置参数同option</p>
</blockquote>
<p>可以通过Request构造器函数创建一个新的请求对象，这也是建议标准的一部分。 第一个参数是请求的URL，第二个参数是一个选项对象，用于配置请求。请求对象一旦创建了， 你便可以将所创建的对象传递给fetch()方法，用于替代默认的URL字符串.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(URL, &#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">cache</span>: <span class="string">'reload'</span>&#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  insertPhotos(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有关Request对象的另一件更酷的事在于，你还可以基于原有的对象创建一个新的对象。新的请求和旧的并没有什么不同，但你可以通过稍微调整配置对象，将其用于不同的场景。例如，你可以基于原有的GET请求创建一个POST请求，它们具有相同的请求源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于req对象创建新的postReq对象</span></span><br><span class="line"><span class="keyword">var</span> postReq = <span class="keyword">new</span> Request(req, &#123;<span class="attr">method</span>: <span class="string">'POST'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>每个Request对象都有一个header属性，在Fetch API中它对应了一个Headers对象。 通过Headers对象，你能够修改请求头。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line">myHeaders.append(<span class="string">'Content-Type'</span>, <span class="string">'image/jpeg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = &#123; <span class="attr">method</span>: <span class="string">'GET'</span>,</span><br><span class="line">    headers: myHeaders,</span><br><span class="line">    mode: <span class="string">'cors'</span>,</span><br><span class="line">    cache: <span class="string">'default'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'https://api.github.com/users/mzabriskie'</span>,option);</span><br><span class="line"></span><br><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>Fetch API 的Response接口呈现了对一次请求的响应数据。其包含一次请求的响应信息，响应状态等。</p>
<p>包含的一些常用属性（只读）</p>
<ul>
<li>type：类型,支持: basic, cors</li>
<li>url：包含请求地址url</li>
<li>status：响应状态码（200成功）</li>
<li>ok：一个布尔值标识请求成功或失败(status 值在 200-299 之间)</li>
<li>statusText：包含与状态码对应的状态信息</li>
<li>headers：包含于请求关联的Headers对象</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>clone() - 创建Response对象的克隆</li>
<li>error() - 返回一个新的,与网络错误相关的 Response 对象</li>
<li>redirect() - 重定向,使用新的 URL 创建新的 response 对象</li>
<li>arrayBuffer() - Returns a promise that resolves with an ArrayBuffer.</li>
<li>blob() - 返回一个 promise, resolves 是一个 Blob.</li>
<li>formData() - 返回一个 promise, resolves 是一个 FormData 对象.</li>
<li>json() - 返回一个 promise, resolves 是一个 JSON 对象.</li>
<li>text() - 返回一个 promise, resolves 是一个 USVString (text).</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"https://api.github.com/users/mzabriskie"</span>, &#123;<span class="attr">mode</span>: <span class="string">"no-cors"</span>&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>检测请求是否成功</strong></p>
<p>同XMLHttpResponse一样，请求发出，服务器发出返回码，<strong>除了407以外，其不会进入错误捕捉</strong>。也就是说除了网络故障或者跨域请求被拒绝等请求失败的情况，fetch() 的Promise是不会 reject的，所以为了请求能按照我们的预期实现，我们必须加一个判断，判断请求是否成功并返回了我们想要的数据。我们当然可以像 XMLHttpResponse 一样对响应的状态码进行判断，不过我们还有选择，对<strong>response.ok</strong>这个布尔值入手。在请求成功和失败的情况下，属性 ok 的值 分别为true 和false 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"https://api.github.com/users/mzabriskie"</span>, &#123;<span class="attr">mode</span>: <span class="string">"cors"</span>&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(response.ok) &#123;</span><br><span class="line">        response.json().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求不成功，状态码为"</span>, response.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Fetch常见坑"><a href="#Fetch常见坑" class="headerlink" title="Fetch常见坑"></a>Fetch常见坑</h3><ul>
<li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})。</li>
<li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。（除了407）</li>
</ul>
<p><strong>IE 使用策略</strong></p>
<p>所有版本的 IE 均不支持原生 Fetch，fetch-ie8 会自动使用 XHR 做 polyfill。但在跨域时有个问题需要处理。</p>
<p>IE8, 9 的 XHR 不支持 CORS 跨域，虽然提供 XDomainRequest，但这个东西就是玩具，不支持传 Cookie！如果接口需要权限验证，还是乖乖地使用 jsonp 吧，推荐使用 fetch-jsonp。如果有问题直接提 issue，我会第一时间解决。</p>
<p><strong>标准 Promise 的不足</strong></p>
<p>由于 Fetch 是典型的异步场景，所以大部分遇到的问题不是 Fetch 的，其实是 Promise 的。ES6 的 Promise 是基于 Promises/A+ 标准，为了保持简单简洁，只提供极简的几个 API。如果你用过一些牛 X 的异步库，如 jQuery(不要笑) 、Q.js 或者 RSVP.js，可能会感觉 Promise 功能太少了。</p>
<p><strong>没有 Deferred</strong></p>
<p>Deferred 可以在创建 Promise 时可以减少一层嵌套，还有就是跨方法使用时很方便。<br>ECMAScript 11 年就有过 Deferred 提案，但后来没被接受。其实用 Promise 不到十行代码就能实现 Deferred：es6-deferred。现在有了 async/await，generator/yield 后，deferred 就没有使用价值了。</p>
<p><strong>没有获取状态方法：isRejected，isResolved</strong></p>
<p>标准 Promise 没有提供获取当前状态 rejected 或者 resolved 的方法。只允许外部传入成功或失败后的回调。我认为这其实是优点，这是一种声明式的接口，更简单。</p>
<p><strong>缺少其它一些方法：always，progress，finally</strong></p>
<p>always 可以通过在 then 和 catch 里重复调用方法实现。finally 也类似。progress 这种进度通知的功能还没有用过，暂不知道如何替代。</p>
<p><strong>不能中断，没有 abort、terminate、onTimeout 或 cancel 方法</strong></p>
<p>Fetch 和 Promise 一样，一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject。幸运的是，whatwg 目前正在尝试解决这个问题whatwg/fetch#27</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/JS运行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/JS运行机制/" itemprop="url">JS运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T14:00:59+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><blockquote>
<p><strong>进程</strong>是一个工厂，工厂有它的独立资源-工厂之间相互独立；<br><strong>线程</strong>是工厂中的工人，多个工人协作完成任务-工厂内有一个或多个工人-工人之间共享空间。</p>
<p>工厂的资源-&gt;系统分配的内存（独立的一块内存）-工厂之间的相互独立-&gt;进程之间相互独立-多个工人协作完成任务-&gt;多个线程在进程中协作完成任务-工厂内有一个或多个工人-&gt;一个进程由一个或多个线程组成-工人之间共享空间-&gt;同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）.</p>
</blockquote>
<p><strong>概念：</strong></p>
<ul>
<li>进程是CPU资源分配的最小单位，是能拥有资源和独立运行的最小单位。</li>
<li>线程是CPU调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。</li>
</ul>
<p><strong>提示：</strong></p>
<ul>
<li>进程之间也可以通信，但是代价较大。</li>
<li>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是属于一个进程才行）。</li>
</ul>
<h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><ul>
<li>浏览器是多进程的；</li>
<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源(CPU,内存)；</li>
<li>简单理解：没打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li>
</ul>
<p>注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的）。</p>
<p><strong>浏览器包含的主要进程有以下几种：</strong></p>
<h4 id="Browser进程"><a href="#Browser进程" class="headerlink" title="Browser进程"></a>Browser进程</h4><p>这是浏览器主进程，负责协调、主控，只有一个。</p>
<p>作用：</p>
<ul>
<li>负责浏览器界面显示，与用户交互。如前进、后退等；</li>
<li>负责各个页面的管理，创建和销毁其他进程；</li>
<li>将Render进程得到的内存中的Bitmap，绘制到用户界面上；</li>
<li>网络资源的管理，下载等。</li>
</ul>
<h4 id="第三方插件进程"><a href="#第三方插件进程" class="headerlink" title="第三方插件进程"></a>第三方插件进程</h4><p>每种类型的插件对应一个进程，仅当使用该插件时才创建。</p>
<h4 id="CPU进程"><a href="#CPU进程" class="headerlink" title="CPU进程"></a>CPU进程</h4><p>最多一个，用于3D绘制等。</p>
<h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>即浏览器内核，Render进程，其内部是多线程的。默认每个Tab页面一个进程，互不影响。</p>
<p>主要作用：</p>
<ul>
<li>页面渲染</li>
<li>脚本执行</li>
<li>事件处理</li>
</ul>
<h4 id="多进程的优势"><a href="#多进程的优势" class="headerlink" title="多进程的优势"></a>多进程的优势</h4><ul>
<li>避免单个页面崩溃的时候影响整个浏览器；</li>
<li>避免第三方插件崩溃的时候影响整个浏览器；</li>
<li>多进程充分利用多核优势；</li>
<li>方便使用沙盒模式隔离插件等进程，提高浏览器稳定性。</li>
</ul>
<h3 id="重点是浏览器内核-渲染进程"><a href="#重点是浏览器内核-渲染进程" class="headerlink" title="重点是浏览器内核(渲染进程)"></a>重点是浏览器内核(渲染进程)</h3><p>页面的渲染，JS的执行，事件循环，都是在这个进程内进行。</p>
<blockquote>
<p>强调一遍：渲染进程是多线程的。</p>
</blockquote>
<h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><ul>
<li>负责渲染浏览器界面，解析HTML、CSS、构建DOM树和渲染树，布局和绘制等。</li>
<li>当界面需要重绘或由于某种操作引发回流的时候，该线程就会执行。</li>
</ul>
<blockquote>
<p>注意！GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起， GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
</blockquote>
<h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h4><ul>
<li>也称为“JS内核”，负责处理JavaScript脚本程序。</li>
<li>JS引擎线程负责解析JavaScript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS线程在运行JS程序。</li>
</ul>
<blockquote>
<p>再次注意！GUI渲染线程和JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
</blockquote>
<h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul>
<li>用来控制事件循环。</li>
<li>当JS引擎执行代码块如setTimeout时（也可以来自浏览器内核其他线程，如鼠标点击，Ajax异步请求等），会将对应任务添加到事件线程中。</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li>
</ul>
<blockquote>
<p>注意！由于JS的单线程的关系，所以这些待处理队列中的事件都得排队等待JS引擎处理(JS引擎空闲时才会去执行)</p>
</blockquote>
<h4 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h4><ul>
<li>setTimeout和setInterval所在的线程。</li>
<li>浏览器定时计数器并不是由JS引擎计数的（因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性）。</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。</li>
</ul>
<blockquote>
<p>注意！W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p>
</blockquote>
<h4 id="异步HTTP请求线程"><a href="#异步HTTP请求线程" class="headerlink" title="异步HTTP请求线程"></a>异步HTTP请求线程</h4><ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求。</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将这个回调再放入事件队列中。再由JS引擎执行。</li>
</ul>
<h3 id="Browser进程和浏览器内核的通信过程"><a href="#Browser进程和浏览器内核的通信过程" class="headerlink" title="Browser进程和浏览器内核的通信过程"></a>Browser进程和浏览器内核的通信过程</h3><ul>
<li>Browser进程收到用户请求，首先需要获取页面内容，随后将该任务通过RenderHost接口传递给渲染进程；</li>
<li>Render进程的RenderHost接口收到信息，简单解释后，交给渲染线程，然后开始渲染；</li>
<li>渲染线程收到请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GUI进程来帮助渲染；</li>
<li>当然可能会有JS线程操作DOM(这样可能会造成回流并重绘)；</li>
<li>最后Render进程将结果传递给Browser进程；</li>
<li>Browser进程接收到结果并将结果绘制处理。</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="GUI渲染和JS引擎互斥"><a href="#GUI渲染和JS引擎互斥" class="headerlink" title="GUI渲染和JS引擎互斥"></a>GUI渲染和JS引擎互斥</h4><p>由于JavaScript是可以操作DOM的，如果咋修改这些元素同时渲染界面(即JS线程和UI线程同时运行)，那么渲染线程前后获得元素数据就不一致了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>
<h4 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h4><p>当JS引擎正在进行大量的计算时，就算GUI有更新，也会被保存在队列中，等待JS引擎空闲时执行。然后，由于巨量计算，所以JS引擎很可能很长时间后才能空闲，就会感觉到页面巨卡。</p>
<p>所以要尽量避免JS执行时间过长，这样会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
<h4 id="WebWorker-多线程"><a href="#WebWorker-多线程" class="headerlink" title="WebWorker 多线程"></a>WebWorker 多线程</h4><blockquote>
<p>WebWorker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一个worker是使用一个构造函数创建的一个对象(e.g.Worker())，运行一个命名的JavaScript文件，这个文件包含将在工作线程中运行的代码;workers运行在另一个全局上下文中,不同于当前的window因此，使用window快捷方式获取当前全局的范围(而不是self)在一个Worker内将返回错误。</p>
</blockquote>
<ul>
<li>创建worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）。</li>
<li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列号对象来与线程交互特定的数据）。</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个worker线程，这样里面不管如何让翻天覆地都不会影响JS引擎主线程，只需等待计算出结果后，将结果通信给主线程即可。</p>
<blockquote>
<p>注意！JS引擎是单线程的，这一点本质仍然未改变，worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
</blockquote>
<p><strong>WebWorker与SharedWorker</strong></p>
<ul>
<li>WebWorker只属于某个页面，不会和其他页面的Render进程共享。</li>
<li>所以Chrome在Render进程中，创建一个新的线程来运行worker中的JS程序。</li>
<li>SharedWorker是浏览器所有页面共享的，不能采用与worker同样的方式出现，因为它不属于某个Render进程，可以为多个Render进程共享使用。</li>
<li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li>
</ul>
<blockquote>
<p>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程。</p>
</blockquote>
<h4 id="css加载是否会阻塞DOM树渲染"><a href="#css加载是否会阻塞DOM树渲染" class="headerlink" title="css加载是否会阻塞DOM树渲染"></a>css加载是否会阻塞DOM树渲染</h4><p>css是单独的下载线程异步下载的。</p>
<ul>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）。</li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）。</li>
</ul>
<p>这可能也是浏览器的一种优化机制。</p>
<p>因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。</p>
<p>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p>
<h4 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h4><p>可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层。</p>
<ul>
<li><p>首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p>
</li>
<li><p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>
</li>
<li><p>然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源<br>（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>
</li>
</ul>
<p>可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒。</p>
<p><strong>如何变成复合图层</strong></p>
<p>将该元素变成一个复合图层，就是传说中的<strong>硬件加速</strong>技术</p>
<ul>
<li>最常用的方式：translate3d、translateZ</li>
<li>opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）。</li>
<li>will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）。</li>
<li>&lt;\video&gt;&lt;\iframe&gt;&lt;\canvas&gt;&lt;\webgl&gt;等元素。</li>
<li>其它，譬如以前的flash插件。</li>
</ul>
<p><strong>absolute和硬件加速的区别</strong></p>
<ul>
<li>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。</li>
<li>所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。</li>
</ul>
<p>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p>
<ul>
<li>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</li>
</ul>
<p><strong>复合图层的作用</strong></p>
<p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p>
<p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p>
<p><strong>硬件加速时请使用index</strong></p>
<p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染。</p>
<p>具体的原理时这样的：</p>
<ul>
<li>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，</li>
<li>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能。</li>
</ul>
<p>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意。</p>
<h3 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h3><ul>
<li>JS分为同步任务和异步任务</li>
<li>同步任务都在主线程上执行，形成一个执行栈。</li>
<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>
</ul>
<p><strong>定时器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello!'</span>);&#125;,<span class="number">0</span>);<span class="built_in">console</span>.log(<span class="string">'begin'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果是：先begin后hello!</li>
<li>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。<br>(不过也有一说是不同浏览器有不同的最小时间设定)</li>
<li>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）</li>
</ul>
<p><strong>setTimeout而不是setInterval</strong></p>
<p>用setTimeout模拟定期计时和直接用setInterval是有区别的。</p>
<ul>
<li>因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关）。</li>
<li>而setInterval则是每次都精确的隔一段时间推入一个事件<br>（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</li>
</ul>
<p>而且setInterval有一些比较致命的问题就是：</p>
<ul>
<li>累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）</li>
<li>譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调）</li>
<li>而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时。</li>
</ul>
<p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame</p>
<h4 id="macrotask和microtask"><a href="#macrotask和microtask" class="headerlink" title="macrotask和microtask"></a>macrotask和microtask</h4><p>JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task。</p>
<ul>
<li><strong>macrotask</strong>（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</li>
<li>每一个task会从头到尾将这个任务执行完毕，不会执行其它。</li>
<li><p>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染<br>（task-&gt;渲染-&gt;task-&gt;…）</p>
</li>
<li><p><strong>microtask</strong>（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。</p>
</li>
<li>也就是说，在当前task任务后，下一个task之前，在渲染之前。</li>
<li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</li>
<li>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</li>
</ul>
<p><strong>macrotask和microtask场景</strong></p>
<ul>
<li>macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</li>
<li>microtask：Promise，process.nextTick等</li>
</ul>
<blockquote>
<p>在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。</p>
<p>另外，setImmediate则是规定：在下一次Event Loop（宏任务）时触发（所以它是属于优先级较高的宏任务），（Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面），所以setImmediate如果嵌套的话，是需要经过多个Loop才能完成的，而不会像process.nextTick一样没完没了。</p>
</blockquote>
<p>macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护。</p>
<p>microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护。</p>
<p><strong>运行机制流程：</strong></p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<p>另外，请注意下Promise的polyfill与官方版本的区别：</p>
<ul>
<li>官方版本中，是标准的microtask形式</li>
<li>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式</li>
</ul>
<blockquote>
<p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p>
</blockquote>
<p>MutationObserver可以用来实现microtask（它属于microtask，优先级小于Promise，一般是Promise不支持时才会这样做）</p>
<p>它是HTML5中的新特性，作用是：监听一个DOM变动，当DOM对象树发生任何变动时，Mutation Observer会得到通知.</p>
<p>像以前的Vue源码中就是利用它来模拟nextTick的，具体原理是，创建一个TextNode并监听内容变化，然后要nextTick的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter=<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> observer=newMutationObserver(nextTickHandler)</span><br><span class="line"><span class="keyword">var</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">observer.observe(textNode,&#123;<span class="attr">characterData</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">timerFunc=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    counter=(counter+<span class="number">1</span>)%<span class="number">2</span></span><br><span class="line">    textNode.data=<span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因），取而代之的是使用MessageChannel（当然，默认情况仍然是Promise，不支持才兼容的）。</p>
<p>MessageChannel属于宏任务，优先级是：setImmediate-&gt;MessageChannel-&gt;setTimeout，所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/19/JS函数节流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/JS函数节流/" itemprop="url">JS函数节流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T21:24:43+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="节流的目的"><a href="#节流的目的" class="headerlink" title="节流的目的"></a>节流的目的</h3><p><strong>函数节流就是用来节流函数从而一定程度上优化性能的</strong>。</p>
<p>例如，DOM 操作比起非DOM 交互需要更多的内存和CPU 时间。连续尝试进行过多的DOM 相关操作可能会导致浏览器挂起，有时候甚至会崩溃。尤其在IE 中使用onresize 事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。在onresize 事件处理程序内部如果尝试进行DOM 操作，其高频率的更改可能会让浏览器崩溃。</p>
<p>又例如，我们常见的一个搜索的功能，我们一般是绑定keyup事件，每按下一次键盘就搜索一次。但是我们的目的主要是每输入一些内容搜索一次而已。为了解决这些问题，就可以使用定时器对函数进行节流。</p>
<h3 id="节流的原理"><a href="#节流的原理" class="headerlink" title="节流的原理"></a>节流的原理</h3><p>某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。<strong>目的是只有在执行函数的请求停止了一段时间之后才执行。</strong></p>
<h3 id="节流的基本模式"><a href="#节流的基本模式" class="headerlink" title="节流的基本模式"></a>节流的基本模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> processor = &#123;</span><br><span class="line">   timeoutId: <span class="literal">null</span>,</span><br><span class="line">     <span class="comment">//实际进行处理的方法</span></span><br><span class="line">   performProcessing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//实际执行的代码</span></span><br><span class="line">   &#125;,</span><br><span class="line">  <span class="comment">//初始处理调用的方法</span></span><br><span class="line">  process: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timeoutId);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      that.performProcessing();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//尝试开始执行</span></span><br><span class="line">processor.process();</span><br></pre></td></tr></table></figure>
<h3 id="输入框搜索节流"><a href="#输入框搜索节流" class="headerlink" title="输入框搜索节流"></a>输入框搜索节流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'搜索'</span>+text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'search'</span>);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    throttle(queryData,<span class="literal">null</span>,<span class="number">500</span>,<span class="keyword">this</span>.value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, context, delay, text</span>)</span>&#123;</span><br><span class="line">    clearTimeout(fn.timeoutId);</span><br><span class="line">    </span><br><span class="line">    fn.timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fn.call(context,text);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题就是，假如我不断地输入，输入了很多内容，但是我每两次之间的输入间隔都小于自己设置的delay值，那么，这个queryData搜索函数就一直得不到调用。实际上，我们更希望的是，当达到某个时间值时，一定要执行一次这个搜索函数。所以，就有了函数节流的改进模式。</p>
<p><strong>增强版</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'搜索'</span>+text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'search'</span>);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    throttle(queryData,<span class="literal">null</span>,<span class="number">500</span>,<span class="keyword">this</span>.value, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, context, delay, text, mustApplyTime</span>)</span>&#123;</span><br><span class="line">    clearTimeout(fn.timer);</span><br><span class="line">    fn._cur=<span class="built_in">Date</span>.now();  <span class="comment">//记录当前时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若该函数是第一次调用，则直接设置_start,即开始时间，为_cur，即此刻的时间</span></span><br><span class="line">    <span class="keyword">if</span>(!fn._start)&#123;</span><br><span class="line">        fn._start = fn._cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前时间与上一次函数被执行的时间作差，与mustApplyTime比较，若大于，则必须执行一次函数，若小于，则重新设置计时器</span></span><br><span class="line">    <span class="keyword">if</span>(fn._cur - fn._start &gt; mustApplyTime)&#123;</span><br><span class="line">        fn.call(context, text);</span><br><span class="line">        fn._start = fn._cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fn.timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.call(context, text);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，连续的输入，到一定时间间隔之后，queryData函数必然会被调用，但是又不是频繁的调用。这既达到了节流的目的，又不会影响用户体验。</p>
<p>进一步的话，就是可以在调用throttle函数之前，先对输入的内容进行判断，若其值为空、值不变都不用再调用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/19/手撕代码备录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/手撕代码备录/" itemprop="url">手撕代码备录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T18:41:33+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Clone函数"><a href="#Clone函数" class="headerlink" title="Clone函数"></a>Clone函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span>.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> e <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">        o[e] = <span class="keyword">typeof</span> <span class="keyword">this</span>[e] === <span class="string">"object"</span> ? <span class="keyword">this</span>[e].clone() : <span class="keyword">this</span>[e];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">nm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(nm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数柯里化</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context,args.slice(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context,...res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context,[...res,...arg])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求一个字符串字节长度"><a href="#求一个字符串字节长度" class="headerlink" title="求一个字符串字节长度"></a>求一个字符串字节长度</h3><blockquote>
<p>英文占用一个字节，中文占用两个字节</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = str.length;</span><br><span class="line">    <span class="keyword">var</span> bytes = len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charCodeAt(i) &gt; <span class="number">255</span>)&#123;</span><br><span class="line">            bytes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将时间设为当前时间前一天"><a href="#将时间设为当前时间前一天" class="headerlink" title="将时间设为当前时间前一天"></a>将时间设为当前时间前一天</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">date.setDate(date.getDate() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获取URL中的查询参数"><a href="#获取URL中的查询参数" class="headerlink" title="获取URL中的查询参数"></a>获取URL中的查询参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = <span class="built_in">window</span>.location.href;</span><br><span class="line">    <span class="keyword">var</span> query = href.split(<span class="string">'?'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(query[<span class="number">0</span>] == href)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arr = query[<span class="number">1</span>].split(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = arr[i].split(<span class="string">'='</span>);</span><br><span class="line">        obj[item[<span class="number">0</span>]] = item[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清除字符串前后空格"><a href="#清除字符串前后空格" class="headerlink" title="清除字符串前后空格"></a>清除字符串前后空格</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str &amp;&amp; <span class="keyword">typeof</span> str === <span class="string">"string"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)|(\s*)$/g</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用正则表达式验证邮箱格式"><a href="#使用正则表达式验证邮箱格式" class="headerlink" title="使用正则表达式验证邮箱格式"></a>使用正则表达式验证邮箱格式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w&#123;2,3&#125;)&#123;1,3&#125;)$/</span>;</span><br><span class="line"><span class="keyword">var</span> email = <span class="string">"example@qq.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(email));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="实现一个100长度的数组，索引值和值相同（不适用循环语句）"><a href="#实现一个100长度的数组，索引值和值相同（不适用循环语句）" class="headerlink" title="实现一个100长度的数组，索引值和值相同（不适用循环语句）"></a>实现一个100长度的数组，索引值和值相同（不适用循环语句）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">[...arr.keys()];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="built_in">Array</span>.from(arr.keys());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>:<span class="number">100</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">arr,val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(val))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(val);</span><br><span class="line">    <span class="keyword">return</span> reduce(arr,val+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/19/DOM操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/DOM操作/" itemprop="url">DOM操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T17:03:22+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h3><ul>
<li><strong>createDocumentFragment()</strong>：创建一个DOM片段</li>
<li><strong>createEelement()</strong>：创建一个具体的元素</li>
<li><strong>createTextNode()</strong>：创建一个文本节点</li>
<li><strong>createAttribute()</strong>：创建新的属性节点</li>
<li><strong>createComment()</strong>：创建新的注释节点</li>
</ul>
<blockquote>
<p>element.innerHTML=’text’；也可以添加文本内容</p>
</blockquote>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><ul>
<li><strong>parent.appendChild()</strong>：向父节点最后添加一个新节点</li>
<li><strong>parent.insertBefore(new,existing)</strong>：向父节点某个特定子节点之前插入新节点</li>
<li><strong>element.setAttributeNode()</strong>：给元素增加属性节点</li>
<li><strong>element.setAttribute(name，value)</strong>：给元素增加指定属性，并设定属性值</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li><strong>parent.removeChild()</strong>：删除已有子节点，返回值为删除节点</li>
<li><strong>element.removeAttribute()</strong>：删除具有指定属性名称的属性，无返回值</li>
<li><strong>element.removeAttributeNode()</strong>：删除指定属性，返回值为删除的属性</li>
</ul>
<h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><ul>
<li><strong>parent.replaceChild(new,existing)</strong>：用新节点替换父节点已有的子节点</li>
<li><strong>element.setAttributeNode()</strong>：若元素已有该节点，此操作能达到修改该属性值得目的</li>
<li><strong>element.setAttribute(name,value)</strong>：若元素已有该节点，此操作能达到修改该属性值得目的</li>
</ul>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><ul>
<li><strong>getElementById()</strong>：通过元素id获取元素</li>
<li><strong>getelementsByName()</strong>：通过元素name属性的值获取所有匹配的元素</li>
<li><strong>getElementsByTagName()</strong>：通过标签名获取所有匹配的元素</li>
<li><strong>getElementsByClassName()</strong>：通过class获取所有匹配的元素</li>
</ul>
<ul>
<li><strong>querySelector()</strong>：通过css选择器获取匹配的第一个元素</li>
<li><strong>querySelectorAll()</strong>：通过css选择器获取所有匹配的元素</li>
</ul>
<ul>
<li><strong>docuemnt.documentElement</strong>：获取页面中的HTML标签</li>
<li><strong>document.body</strong>：获取页面中的body标签</li>
<li><strong>document.all[]</strong>：获取所有元素节点的对象集合</li>
</ul>
<h3 id="常用DOM属性"><a href="#常用DOM属性" class="headerlink" title="常用DOM属性"></a>常用DOM属性</h3><ul>
<li><strong>innerHTML</strong> ：获取节点的文本值</li>
<li><strong>parentNode</strong>：获取父节点</li>
<li><strong>childNodes</strong>：获取元素的子节点</li>
<li><strong>attributes</strong>：获取元素的属性节点</li>
<li><strong>getAttribute()</strong>：返回指定的属性值</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/开放性问题备录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/开放性问题备录/" itemprop="url">开放性问题备录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T22:28:53+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前端工程师的价值"><a href="#前端工程师的价值" class="headerlink" title="前端工程师的价值"></a>前端工程师的价值</h3><ul>
<li>为简化用户使用提供技术支持（交互部分）</li>
<li>为多个浏览器兼容性提供支持</li>
<li>为提高用户浏览速度（浏览器性能）提供支持</li>
<li>为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持</li>
<li>为展示数据提供支持（数据接口）</li>
</ul>
<h3 id="前端工程师的工作"><a href="#前端工程师的工作" class="headerlink" title="前端工程师的工作"></a>前端工程师的工作</h3><ul>
<li>参与项目，快速高质量完成实现效果图，精确到1px；</li>
<li>与团队成员，UI设计，产品经理的沟通；</li>
<li>做好的页面结构，页面重构和用户体验；</li>
<li>处理hack，兼容、写出优美的代码格式；</li>
<li>针对服务器的优化、拥抱最新前端技术。</li>
</ul>
<blockquote>
<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/jQuery知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/jQuery知识点/" itemprop="url">jQuery知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T22:12:04+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jQuery/" itemprop="url" rel="index">
                    <span itemprop="name">jQuery</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>jQuery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//用一个函数域包起来，就是所谓的沙箱</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//把当前沙箱需要的外部变量通过函数参数引入进来</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"></span><br><span class="line">    &#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure>
<p>jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。</p>
<p>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。</p>
<p>jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/React生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/React生命周期/" itemprop="url">React生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T13:18:48+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/react生命周期.jpg" alt="image"></p>
<p>React 生命周期分为三种状态 </p>
<ol>
<li>初始化 </li>
<li>更新 </li>
<li>销毁</li>
</ol>
<ul>
<li>getDefaultProps()：设置默认的props，也可以用dufaultProps设置组件的默认属性.</li>
<li>getInitialState()：在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props</li>
<li>componentWillMount()：组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</li>
<li>render()：react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</li>
<li>componentDidMount()：组件渲染之后调用，只调用一次。可以通过this.getDOMNode()来访问DOM结构。</li>
<li>componentWillUpdate(nextProps,nextState)：组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state</li>
<li>componentDidUpdate(prevProps,prevState)：组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</li>
<li>componentWillUnmount()：组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</li>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用。</li>
</ul>
<blockquote>
<p>shouldComponentUpdate(nextProps, nextState): react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/MVC、MVP、MVVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aisling Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LittleCorn个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/MVC、MVP、MVVM/" itemprop="url">MVC、MVP、MVVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T12:10:12+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Controller）：业务逻辑</li>
<li>模型（Model）：数据保存</li>
</ul>
<p>各部分之间的通信方式如下:</p>
<p><img src="/images/MVC.png" alt="image"></p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈。</li>
</ol>
<p><strong>所有通信都是单向的。</strong></p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<p><img src="/images/MVP.png" alt="image"></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p><img src="/images/MVVM.png" alt="image"></p>
<p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="Aisling Chen" />
            
              <p class="site-author-name" itemprop="name">Aisling Chen</p>
              <p class="site-description motion-element" itemprop="description">生活不止苟且，还有诗和远方</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aisling Chen</span>

  
</div>

<!-- 
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>
 


  <span class="post-meta-divider">|</span>
 


  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
 -->

 

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
